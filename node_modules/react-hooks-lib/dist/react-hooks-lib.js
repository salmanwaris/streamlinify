function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var shallowEqual = _interopDefault(require('shallowequal'));
var deepEqual = _interopDefault(require('lodash.isequal'));
var React = require('react');
var React__default = _interopDefault(React);

var useToggle = function (initial) {
  if ( initial === void 0 ) initial = false;

  var ref = React.useState(initial);
  var on = ref[0];
  var setToggle = ref[1];
  return {
    on: on,
    set: setToggle,
    reset: function () { return setToggle(initial); },
    toggle: function () { return setToggle(function (prev) { return !prev; }); }
  };
};

var add = function (value) { return function (prev) { return prev + value; }; };

var useCounter = function (initial) {
  if ( initial === void 0 ) initial = 0;

  var ref = React.useState(initial);
  var count = ref[0];
  var set = ref[1];
  return {
    count: count,
    set: set,
    inc: function (number) {
      if ( number === void 0 ) number = 1;

      return set(add(number));
  },
    dec: function (number) {
      if ( number === void 0 ) number = 1;

      return set(add(-number));
  },
    reset: function () { return set(initial); }
  };
};

var useHover = function () {
  var ref = React.useState(false);
  var hovered = ref[0];
  var set = ref[1];
  return {
    hovered: hovered,
    bind: {
      onMouseEnter: function () { return set(true); },
      onMouseLeave: function () { return set(false); }
    }
  };
};

var useActive = function () {
  var ref = React.useState(false);
  var active = ref[0];
  var set = ref[1];
  return {
    active: active,
    bind: {
      onMouseDown: function () { return set(true); },
      onMouseUp: function () { return set(false); }
    }
  };
};

var useFocus = function () {
  var ref = React.useState(false);
  var focused = ref[0];
  var set = ref[1];
  return {
    focused: focused,
    bind: {
      onFocus: function () { return set(true); },
      onBlur: function () { return set(false); }
    }
  };
};

var useTouch = function () {
  var ref = React.useState(false);
  var touched = ref[0];
  var set = ref[1];
  return {
    touched: touched,
    bind: {
      onTouchStart: function () { return set(true); },
      onTouchEnd: function () { return set(false); }
    }
  };
};

var useList = function (initial) {
  if ( initial === void 0 ) initial = [];

  var ref = React.useState(initial);
  var list = ref[0];
  var set = ref[1];
  return {
    list: list,
    set: set,
    reset: function () { return set(initial); },
    push: function () {
      var values = [], len = arguments.length;
      while ( len-- ) values[ len ] = arguments[ len ];

      return set(function (prev) { return prev.concat( values); });
  },
    sort: function (fn) { return set(function (prev) { return [].concat( prev ).sort(fn); }); },
    filter: function (fn) { return set(function (prev) { return prev.filter(fn); }); }
  };
};

function objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }

var useMap = function (initial) {
  if ( initial === void 0 ) initial = {};

  var ref = React.useState(initial);
  var values = ref[0];
  var set = ref[1];
  return {
    values: values,
    reset: function () { return set(initial); },
    clear: function () { return set({}); },
    get: function (key) { return values[key]; },
    has: function (key) { return Object.prototype.hasOwnProperty.call(values, key); },
    del: function (key) { return set(function (ref) {
      var rest$1 = objectWithoutProperties( ref, [String(key)] );
      var rest = rest$1;

      return rest;
      }); },
    set: function (key, updater) { return set(function (prev) {
      var obj;

      return (Object.assign({}, prev,
      ( obj = {}, obj[key] = typeof updater === 'function' ? updater(prev[key]) : updater, obj )));
      }); }
  };
};

var useField = function (initial) {
  var ref = React.useState(initial);
  var value = ref[0];
  var set = ref[1];
  return {
    value: value,
    set: set,
    reset: function () { return set(initial); },
    bind: {
      value: value,
      onChange: function (e) { return set(e.target.value); }
    }
  };
};

var useCheckbox = function (initial) {
  var ref = React.useState(initial);
  var checked = ref[0];
  var set = ref[1];
  return {
    checked: checked,
    set: set,
    reset: function () { return set(initial); },
    bind: {
      checked: checked,
      onChange: function (e) { return set(e.target.checked); }
    }
  };
};

var isNil = function (x) { return x == null; };
var cancelablePromise =
/* istanbul ignore next */
function (promise) {
  var hasCanceled = false;
  var wrappedPromise = new Promise(function (resolve, reject) {
    promise.then(function (val) { return hasCanceled ? reject({
      isCanceled: true
    }) : resolve(val); });
    promise.catch(function (error) { return hasCanceled ? reject({
      isCanceled: true
    }) : reject(error); });
  });
  return {
    promise: wrappedPromise,

    cancel: function cancel() {
      hasCanceled = true;
    }

  };
};
var hasOwn =
/* istanbul ignore next */
Object.prototype.hasOwnProperty;

var is =
/* istanbul ignore next */
function (x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  }

  return x !== x && y !== y; // eslint-disable-line
};

var shallowEqual$1 =
/* istanbul ignore next */
function (objA, objB) {
  if (is(objA, objB)) { return true; }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) { return false; }

  for (var i = 0; i < keysA.length; i++) {
    //eslint-disable-line
    if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
};
var identity = function (x) { return x; };
var toPath = function (x) {
  if ( x === void 0 ) x = '';

  if (Array.isArray(x)) {
    return x;
  }

  return x.toString().replace(/[[\]]/g, '.').split('.').reduce(function (acc, item) {
    if (item.trim() !== '') {
      acc.push(item);
    }

    return acc;
  }, []);
};
var get = function (obj, pathString, defaultValue) {
  var path = toPath(pathString);
  var res = path.reduce(function (acc, key) {
    if (isNil(acc)) {
      return undefined;
    }

    return acc[key];
  }, obj);
  return isNil(res) ? defaultValue : res;
};
var isPlainObject = function (value) { return Object.prototype.toString.call(value) === '[object Object]'; };

var copyCurrentValue = function (obj, nextKey) {
  if (Array.isArray(obj)) {
    return [].concat( obj );
  }

  if (isPlainObject(obj)) {
    return Object.assign({}, obj);
  }

  if (/[0-9]+/.test(nextKey) && parseInt(nextKey, 10).toString() === nextKey.toString()) {
    return [];
  }

  return {};
};

var set = function (obj, pathString, value) {
  var path = toPath(pathString);

  if (path.length === 0) {
    return value;
  }

  var result = copyCurrentValue(obj, path[0]);
  path.reduce(function (acc, currentKey, index) {
    var hasNext = index !== path.length - 1;
    var nextKey = path[index + 1];

    if (hasNext) {
      acc[currentKey] = copyCurrentValue(acc[currentKey], nextKey);
    } else {
      acc[currentKey] = value;
    }

    return acc[currentKey];
  }, result);
  return result;
};

var useMergeState = function (initial) {
  if ( initial === void 0 ) initial = {};

  var ref = React.useState(initial);
  var state = ref[0];
  var set = ref[1];
  return {
    state: state,
    set: function (updater) { return set(function (prev) { return typeof updater === 'function' ? Object.assign({}, prev,
      updater(prev)) : Object.assign({}, prev,
      updater); }); }
  };
};

var useFetch = function (initialUrl, initialOptions, ref) {
  if ( initialOptions === void 0 ) initialOptions = {};
  if ( ref === void 0 ) ref = {};
  var onMount = ref.onMount; if ( onMount === void 0 ) onMount = true;
  var onResponse = ref.onResponse; if ( onResponse === void 0 ) onResponse = function () {};

  var ref$1 = React.useState({
    url: initialUrl,
    options: initialOptions
  });
  var config = ref$1[0];
  var setConfig = ref$1[1];
  var ref$2 = useMergeState({
    loading: true,
    data: null,
    error: null
  });
  var state = ref$2.state;
  var set$$1 = ref$2.set;
  var canFetchRef = React.useRef(onMount);
  React.useEffect(function () {
    var url = config.url;
    var options = config.options;

    if (!canFetchRef.current) {
      canFetchRef.current = true;
      return;
    }

    var cancelable = cancelablePromise(fetch(url, options));
    set$$1({
      loading: true
    });
    cancelable.promise.then(function (res) { return res.json(); }).then(function (newData) {
      set$$1(function (ref) {
        var error = ref.error;

        onResponse(error, newData);
        return {
          data: newData,
          loading: false
        };
      });
      return newData;
    }).catch(function (e) {
      set$$1(function (ref) {
        var data = ref.data;

        onResponse(e, data);
        return {
          error: e,
          loading: false
        };
      });
      return e;
    });
    return function () { return cancelable.cancel(); }; // eslint-disable-line
  }, [config.url, config.options]);

  var updateConfig = function (key) { return function (updater) { return setConfig(function (prev) {
    var obj;

    var updated = typeof updater === 'function' ? updater(prev[key]) : updater; // make sure not to re-fetch data when updated is shallow equal to prev[key]

    if (shallowEqual$1(updated, prev[key])) {
      return prev;
    }

    return Object.assign({}, prev,
      ( obj = {}, obj[key] = updated, obj ));
  }); }; };

  return {
    setUrl: updateConfig('url'),
    setOptions: updateConfig('options'),
    setData: function (updater) { return set$$1(function (ref) {
      var data = ref.data;

      return typeof updater === 'function' ? {
      data: updater(data)
    } : {
      data: updater
    };
      }); },
    loading: state.loading,
    data: state.data,
    error: state.error,
    fetch: function (urlUpdater, optionsUpdater) { return setConfig(function (prev) { return ({
      url: typeof urlUpdater === 'function' ? urlUpdater(prev.url) : urlUpdater || prev.url,
      // change reference of optionsï¼Œ so that we can re-fetch data when call fetch
      options: typeof optionsUpdater === 'function' ? optionsUpdater(prev.options) : Object.assign({}, (optionsUpdater || prev.options))
    }); }); }
  };
};

var useOnlineStatus = function () {
  var ref = React.useState(navigator.onLine);
  var online = ref[0];
  var set = ref[1];

  var handleOnline = function () { return set(true); };

  var handleOffline = function () { return set(false); };

  React.useEffect(function () {
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return function () {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  return {
    online: online
  };
};

var useDidMount = function (f) { return React.useEffect(function () { return f && f(); }, []); };

var useDidUpdate = function (f, conditions) {
  var didMountRef = React.useRef(false);
  React.useEffect(function () {
    if (!didMountRef.current) {
      didMountRef.current = true;
      return;
    } // Cleanup effects when f returns a function


    return f && f(); //eslint-disable-line
  }, conditions);
};

var useWillUnmount = function (f) { return React.useEffect(function () { return function () { return f && f(); }; }, []); };

var createGlobalState = function (initial) {
  if ( initial === void 0 ) initial = {};

  var state = initial;
  var listeners = [];

  var getState = function () { return state; };

  var subscribe = function (f) {
    if ( f === void 0 ) f = identity;

    listeners.push(f);
    return function () {
      listeners = listeners.filter(function (l) { return l !== f; });
    };
  };

  var set$$1 = function (updater) {
    if (typeof updater === 'function') {
      state = updater(state);
    } else {
      state = updater;
    }

    listeners.forEach(function (f) { return f(state); });
  };

  var initialStore = {
    getState: getState,
    subscribe: subscribe,
    set: set$$1
  };
  var context = React.createContext(initialStore);
  var Provider = context.Provider;
  var Consumer = context.Consumer;

  var GlobalProvider = function (ref) {
    var children = ref.children;

    return React__default.createElement( Provider, { value: initialStore },
      children
    );
  };

  var useStore = function () {
    var store = React.useContext(context);
    return store;
  };

  var useSelector = function (selector) {
    if ( selector === void 0 ) selector = identity;

    var initialValue = selector(state);
    var ref = React.useState(initialValue);
    var value = ref[0];
    var setValue = ref[1];
    React.useEffect(function () {
      var l = function (newState) {
        var newValue = selector(newState);

        if (newValue !== value) {
          setValue(newValue);
        }
      };

      var unsubscribe = subscribe(l);
      return unsubscribe;
    }, []);
    return value;
  };

  var useSet = function () { return set$$1; };

  var useGlobalState = function () {
    var storeState = useSelector();
    return {
      set: set$$1,
      state: storeState
    };
  };

  return {
    GlobalProvider: GlobalProvider,
    GlobalConsumer: Consumer,
    useStore: useStore,
    useGlobalState: useGlobalState,
    set: set$$1,
    getState: getState,
    useSelector: useSelector,
    useSet: useSet
  };
};

var createContextState = function (initial) {
  if ( initial === void 0 ) initial = {};

  var globalState = createGlobalState(initial);
  return {
    ContextProvider: globalState.GlobalProvider,
    ContextConsumer: globalState.GlobalConsumer,
    set: globalState.set,
    useContextState: globalState.useGlobalState,
    getState: globalState.getState,
    useStore: globalState.useStore,
    useSelector: globalState.useSelector,
    useSet: globalState.useSet
  };
};

var useUndo = function (initial) {
  var ref = useMergeState({
    past: [],
    present: initial,
    future: []
  });
  var state = ref.state;
  var set = ref.set;

  var undo = function () {
    set(function (prevState) {
      var past = prevState.past;
      var present = prevState.present;
      var future = prevState.future;

      if (past.length === 0) {
        return prevState;
      }

      var previous = past[past.length - 1];
      return {
        past: past.slice(0, past.length - 1),
        present: previous,
        future: [present ].concat( future)
      };
    });
  };

  var redo = function () {
    set(function (prevState) {
      var past = prevState.past;
      var present = prevState.present;
      var future = prevState.future;

      if (future.length === 0) {
        return prevState;
      }

      var next = future[0];
      var restFuture = future.slice(1);
      return {
        past: past.concat( [present]),
        present: next,
        future: restFuture
      };
    });
  };

  var setPresent = function (updater) { return set(function (ref) {
    var present = ref.present;
    var past = ref.past;

    return ({
    past: past.concat( [present]),
    present: typeof updater === 'function' ? updater(present) : updater,
    future: []
  });
    }); };

  return Object.assign({}, state,
    {undo: undo,
    redo: redo,
    set: setPresent});
};

var useStateCallback = function (initialState, f) {
  var ref = React.useState(initialState);
  var state = ref[0];
  var set = ref[1];
  useDidUpdate(f, [state]);
  return {
    state: state,
    set: set
  };
};

var isShallowEqual = function (depsA, depsB) {
  if ( depsA === void 0 ) depsA = [];
  if ( depsB === void 0 ) depsB = [];

  if (depsA.length !== depsB.length) {
    return false;
  }

  return depsA.every(function (a, index) { return shallowEqual(a, depsB[index]); });
};

var useEqualEffect = function (compareFn, f, deps) {
  var ref = React.useRef([]);

  if (!compareFn(ref.current, deps)) {
    ref.current = deps;
  }

  React.useEffect(f, ref.current);
};

var useShallowEqualEffect = function (f, deps) {
  useEqualEffect(isShallowEqual, f, deps);
};
var useDeepEqualEffect = function (f, deps) {
  useEqualEffect(deepEqual, f, deps);
};

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var useAsync = function (f) {
  if ( f === void 0 ) f = function () {};

  var ref = React.useState(false);
  var loading = ref[0];
  var setLoading = ref[1];

  var _f = function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    try {
      setLoading(true);
      return Promise.resolve(_catch(function () {
        return Promise.resolve(f.apply(void 0, args)).then(function (res) {
          setLoading(false);
          return res;
        });
      }, function (e) {
        setLoading(false);
        throw e;
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return {
    f: _f,
    loading: loading
  };
};

var useNestedState = function (initial) {
  var ref = React.useState(initial);
  var state = ref[0];
  var setState = ref[1];
  return {
    state: state,
    get: function (pathString, defaultValue) { return get(state, pathString, defaultValue); },
    set: function (pathString, updater) { return setState(function (prev) { return typeof updater === 'function' ? set(prev, pathString, updater(get(prev, pathString))) : set(prev, pathString, updater); }); }
  };
};

var defaultMap = function (e) {
  var tagName = get(e, ['target', 'tagName']);

  if (tagName !== undefined) {
    e.persist();
  }

  if (tagName === 'INPUT') {
    if (e.target.type === 'checkbox' || e.target.type === 'radio') {
      return e.target.checked;
    }

    return e.target.value;
  }

  if (tagName === 'SELECT') {
    var target = e.target;

    if (target.multiple) {
      var value = Array.from(target.options).reduce(function (acc, node) {
        if (node.selected) {
          acc.push(node.value);
        }

        return acc;
      }, []);
      return value;
    }

    return e.target.value;
  }

  if (tagName !== undefined) {
    return e.target.value;
  }

  return e;
};

var useBind = function (initial, options) {
  var obj;

  if ( options === void 0 ) options = {
  propName: 'value',
  handlerName: 'onChange',
  map: defaultMap
};
  var ref = React.useState(initial);
  var value = ref[0];
  var set$$1 = ref[1];
  var propName = options.propName; if ( propName === void 0 ) propName = 'value';
  var handlerName = options.handlerName; if ( handlerName === void 0 ) handlerName = 'onChange';
  var map = options.map; if ( map === void 0 ) map = defaultMap;
  return {
    value: value,
    set: set$$1,
    reset: function () { return set$$1(initial); },
    bind: ( obj = {}, obj[propName] = isNil(value) ? initial : value, obj[handlerName] = function (newValue) {
        set$$1(map(newValue));
      }, obj )
  };
};

var useNestedBind = function (initial) {
  var ref = useNestedState(initial);
  var state = ref.state;
  var set = ref.set;
  var get = ref.get;
  return {
    state: state,
    set: set,
    get: get,
    reset: function () { return set(initial); },
    bindPath: function (path, options) {
      var obj;

      if ( options === void 0 ) options = {
      propName: 'value',
      handlerName: 'onChange',
      defaultValue: undefined,
      map: defaultMap
    };
      var propName = options.propName; if ( propName === void 0 ) propName = 'value';
      var handlerName = options.handlerName; if ( handlerName === void 0 ) handlerName = 'onChange';
      var defaultValue = options.defaultValue;
      var map = options.map; if ( map === void 0 ) map = defaultMap;
      return ( obj = {}, obj[propName] = get(path, defaultValue), obj[handlerName] = function (newValue) { return set(path, map(newValue)); }, obj );
    }
  };
};

exports.useToggle = useToggle;
exports.useCounter = useCounter;
exports.useHover = useHover;
exports.useActive = useActive;
exports.useFocus = useFocus;
exports.useTouch = useTouch;
exports.useList = useList;
exports.useMap = useMap;
exports.useField = useField;
exports.useCheckbox = useCheckbox;
exports.useFetch = useFetch;
exports.useMergeState = useMergeState;
exports.useOnlineStatus = useOnlineStatus;
exports.useDidMount = useDidMount;
exports.useDidUpdate = useDidUpdate;
exports.useWillUnmount = useWillUnmount;
exports.createGlobalState = createGlobalState;
exports.createContextState = createContextState;
exports.useUndo = useUndo;
exports.useStateCallback = useStateCallback;
exports.useShallowEqualEffect = useShallowEqualEffect;
exports.useDeepEqualEffect = useDeepEqualEffect;
exports.useAsync = useAsync;
exports.useNestedState = useNestedState;
exports.useBind = useBind;
exports.useNestedBind = useNestedBind;
